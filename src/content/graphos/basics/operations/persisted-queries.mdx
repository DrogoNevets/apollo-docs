---
title: Operation safelisting with registered persisted queries
description: Reject unrecognized operations while minimizing request latency
---

<blockquote>

**This feature is available only with a [GraphOS Enterprise plan](/graphos/enterprise/).** It is currently in [preview](/resources/product-launch-stages#preview).

If your organization _doesn't_ currently have an Enterprise plan, you can test out this functionality by signing up for a free [Enterprise trial](/graphos/org/plans/#enterprise-trials).

</blockquote>

With [GraphOS Enterprise](../enterprise/), you can enhance your graph's security by maintaining a **persisted query list** (or **PQL**) for your supergraph's self-hosted router. This list should contain _all_ of the trusted GraphQL operations that _all_ of your app clients execute against your router:

```mermaid
graph LR;

  subgraph "CI/CD"
  webClient("Web client<br/>build");
  androidClient("Android client<br/>build");
  end

  subgraph "GraphOS"
  pql[[Persisted<br/>Query List]];
  end
  
  subgraph "Your backend"
  router(["Apollo<br/>Router"]);
  end

  webClient & androidClient -->|Publishes<br/>operations|pql
  router -.->|Fetches PQL<br/>at runtime|pql
```

## Benefits of persisted queries

Your router can use its persisted query list (PQL) to **protect your supergraph** and **speed up your clients**:

- When you enable **operation safelisting**, your router _rejects_ any incoming operations that aren't in its PQL.
    - This helps block requests from unauthorized clients.
    - Enabling safelisting requires coordination across _all_ of your app clients. For details, see [Adoption path](#adoption-path). 
- Client apps can execute an operation by providing its PQL-specified ID, _instead of_ providing a full operation string.
    - For very large operation strings, this can significantly reduce latency and bandwidth usage.
    - Your router can even _require_ that clients provide operations this way and _reject_ full query strings (even query strings that are present in the PQL).

## Differences from APQ

The Apollo Router also supports a related feature called [automatic persisted queries](/router/configuration/in-memory-caching#caching-automatic-persisted-queries-apq), or APQ. With APQ, clients can execute a GraphQL operation by sending the hash of its operation string, instead of sending the full string.

**Compared to GraphOS persisted queries, APQ has the following limitations:**

- APQ doesn't provide safelisting capabilities, because the router populates its APQ cache over time with _any_ operations it receives.
    - **With GraphOS persisted queries,** clients pre-publish their operations to GraphOS. Your router fetches its PQL on startup, enabling it to reject operations that aren't present in the PQL.

- With APQ, one of your router instances must receive any given operation string from a client at least once, in order to [cache it](/router/configuration/distributed-caching).
    - **With GraphOS persisted queries,** your router fetches its full PQL from GraphOS on startup, which means clients can _always_ execute operations by their PQL-specified ID.

If you _only_ want to improve request latency and bandwidth usage, APQ probably addresses your use case. If you _also_ want to secure your supergraph with operation safelisting, you should use GraphOS persisted queries.

## Router security levels

Your router instances with a persisted query list (PQL) can use it to enable one of a few different security levels, which you set up in your router's [YAML config file](/router/configuration/overview/#yaml-config-file).

> When you first adopt persisted queries, you should always start with the _least_ restrictive security level ([performance-only](#performance-only-no-safelisting)). You can then enable increasingly restrictive levels after you make all necessary changes to your clients.

The Apollo Router supports the following security levels, in increasing order of restrictiveness:

- [Performance-only](#performance-only-no-safelisting): Clients can optionally execute an operation on your router by providing the operation's PQL-specified ID.
    - All other levels also provide this core capability.
    - This level provides no operation safelisting.
    - You can optionally turn on logging to see the unregistered queries reaching your graph.
- [Safelisting with query strings allowed](#safelisting-query-strings-allowed): The router _rejects_ any incoming operations that aren't present in its PQL.
    - Before moving to this security level, make sure _all_ of your client operations are present in your PQL.
- [Safelisting with IDs only](#safelisting-ids-only): The router rejects any incoming operations that aren't present in its PQL, _and_ clients _must_ execute an operation by providing its PQL-specified ID.
    - Before moving to this security level, make sure _all_ of your clients execute operations by providing their PQL-specified ID.

See below for details on each level.

### Performance-only (no safelisting)

> **Always start with this security level.** You can enable increasingly restrictive levels after you make all necessary changes to your clients.

To use persisted queries _only_ to reduce network bandwidth and latency (_not_ for safelisting), add the following minimal configuration:

```yaml title="router.yaml"
preview_persisted_queries:
  enabled: true
apq:
  enabled: false # APQ must be disabled
```

This enables your clients to execute operations by providing their PQL-specified ID (instead of the full query string). Your router continues to accept full query strings as well, even for operations that _don't_ appear in its PQL.

To turn on logging for unregistered queries, set enable the `log_unknown` property.

```yaml title="router.yaml"
preview_persisted_queries:
  enabled: true
  log_unknown: true
apq:
  enabled: false # APQ must be disabled
```

### Safelisting (query strings allowed)

> ⚠️ **Before you apply this configuration,** first make sure your PQL contains _all_ of the GraphQL operations that _all active versions_ of your clients execute. If you enable safelisting _without_ ensuring this, your router will reject your unpublished client operations!

With the following configuration, your router allows _only_ GraphQL operations that are present in its PQL, while rejecting all other operations:

```yaml title="router.yaml"
preview_persisted_queries:
  enabled: true
  safelist:
    enabled: true
    freeform_graphql: 
      enabled: true # highlight-line
apq:
  enabled: false # APQ must be disabled 
```

To execute an operation, clients can provide either its full operation string _or_ its PQL-specified ID.

### Safelisting (IDs only)

> ⚠️ **Do not start with this configuration!** It requires _all_ of your clients to execute operations by providing their PQL-specified ID. If any clients still provide full operation strings, those clients will break.

With the following configuration, your router allows _only_ GraphQL operations that are present in its PQL, _and_ it requires clients to provide PQL-specified IDs instead of full query strings:

```yaml title="router.yaml"
preview_persisted_queries:
  enabled: true
  safelist:
    enabled: true
    freeform_graphql:
      enabled: false #highlight-line
apq:
  enabled: false # APQ must be disabled 
```

If you want to use this security level, you should always _first_ set up [safelisting with query strings allowed](#safelisting-query-strings-allowed). That's because this level requires modifying _all_ of your clients to execute operations via PQL-specified ID instead of query string. While you're making those necessary changes, you can use the less restrictive safelisting level in your router.


## Incremental adoption path

Setting up operation safelisting with persisted queries is a multi-step process that requires setting up tooling for _all_ of your client apps. Based on the availability of your client teams, it might take days or even weeks for you to get fully up and running with safelisting.

> If you enable operation safelisting _before_ all of your client apps are publishing their operations to your persisted query list,  your _unpublished_ operations will stop working!

### 0. Prerequisites

Before you get started with GraphOS persisted queries, do all of the following:

#### Coordinate with client teams

1. Identify all of the client apps that execute operations against your router, along with the GraphQL client libraries that those apps use.
    - Before you enable safelisting in your router, your client apps must start publishing their operations to your PQL.
2. Communicate to all of your client development teams that adopting persisted queries will require adding tooling to their CI/CD pipeline.
    - Specifically, each client team will need to perform the following steps of this adoption path: [Generate client operation manifests](#3-generate-client-operation-manifests) and [Publish manifests to the PQL](#4-publish-operations-to-the-pql)
3. Identify which team members will assist with adding tooling to their respective CI/CD pipelines.

#### Update Apollo tooling

1. Update your Apollo Router instances to version `1.25.0` or later. [Download the latest version.](../quickstart/)
    - Previous versions of the Apollo Router don't support configuration for GraphOS persisted queries.
2. Make sure your router instances are [connected to your GraphOS Enterprise organization](/router/enterprise-features/#enabling-enterprise-features).
3. Update your version of the Rover CLI to `0.17.2` or later. [Download the latest version.](/rover/getting-started/)
    - Every client app's CI/CD pipeline uses Rover to publish operations to a PQL.
    - Previous versions of Rover don't support publishing operations to a PQL.

### 1. Create a persisted query list (PQL)

To use persisted queries, you first create a **persisted query list** (**PQL**) in GraphOS Studio. Each PQL is associated with a single graph in GraphOS. You can link a single PQL to any number of different variants of its graph.

1. From your organization's Graphs page in [GraphOS Studio](https://studio.apollographql.com/?referrer=docs-content), open the PQL page for a graph by clicking its PQL button:

  <img
    className="screenshot"
    alt="The persisted query list button in the Studio graph list"
    src="../../img/pql-button.jpg"
  />

2. From the PQL page:

    - If you haven't created any PQLs yet, click **Create a Persisted Query List**.
    - If you already have at least one PQL, click **New List** in the upper right.

  The following dialog appears:

  <img
    className="screenshot"
    alt="The first step of the PQL creation dialog in GraphOS studio"
    src="../../img/pql-dialog-create.jpg"
    width="450"
  />

3. Provide a name and (optional) description for your PQL, then click **Create**.

    - At this point, your empty PQL has been created. The remaining dialog steps help with additional setup.

4. The second dialog step (**Link**) enables you to link your new PQL to one existing variant of your graph.

    - You can optionally **Skip** this step and link variants later (covered in the next step).
    
5. The third dialog step (**Publish**) displays your new PQL's unique ID, along with an example Rover CLI command for publishing operations to the PQL.

    - For now, we'll leave the PQL empty. We'll publish client operations to it in a later step.

6. The fourth and final dialog step (**Configure**) displays configuration options you apply to your router to begin using your PQL. We'll cover these in a later step.

7. Click **Finish** to close the dialog. Your newly created PQL appears in the table:

    <img
      className="screenshot"
      alt="A newly created PQL in the table on the Studio PQL page"
      src="../../img/pql-table.jpg"
      width="450"
    />

### 2. Link the PQL to variants

After you create a PQL, you can link it to one or more variants of your graph. Each router instance associated with a linked variant automatically fetches its PQL from GraphOS.

> It's safe to link an empty or incomplete PQL to a variant, because your router doesn't _use_ its PQL for anything until you configure it to do so (covered in a later step).

1. From the table on your graph's PQL page, open the **•••** menu under the **Actions** column for the PQL you want to link:

    <img
      className="screenshot"
      alt="The Actions menu for a PQL in Studio"
      src="../../img/pql-table-actions.jpg"
      width="250"
    />

2. Click **Link and Unlink Variants**. The following dialog appears:

    <img
      className="screenshot"
      alt="Dialog for linking PQLs to variants in Studio"
      src="../../img/pql-link-variants.jpg"
      width="500"
    />

3. Use the dropdown menu to select any variants you want to link your PQL to.

4. Click **Save**.

After you link a PQL to a variant:

1. GraphOS validates the PQL against the variant's reported operation history and flags any recent operations that aren't represented in the PQL.

2. GraphOS then uploads the PQL to Uplink, the service that delivers configuration to your router at runtime.

> As a best practice, you should link PQLs to your staging _and_ production environments.


### 3. Generate client operation manifests

> You perform this step for _each_ of your client apps. Coordinate this process with representatives from your client teams.

After you create a PQL, you can start publishing operations to it. To do _that_, you need to generate JSON **manifests** of the operations to publish. You generate a separate manifest for each of your client apps.

<ExpansionPanel title="See an example manifest file with two operations">

```json title="persisted-queries.json"
{  
  "format": "apollo-persisted-queries",
  "version": 1,
  "operations": [  
    {
      "id": "dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f",
      "body": "query UniversalQuery { __typename }",
      "name": "UniversalQuery",
      "type": "query" 
    },
    {
      "id": "f11e4dcb28788af2e41689bb366472084aa1aa1e1ba633c3d605279cff08ed59",
      "body": "query FragmentedQuery { post { ...PostFragment } }  fragment PostFragment on Post { id title }",
      "name": "FragmentedQuery",
      "type": "query" 
    }
  ]
}
```

</ExpansionPanel>

You perform manifest generation in your CI/CD pipeline. This enables you to incorporate new operations automatically whenever you release a new client app version.

#### Generation methods

Apollo Client for Web, Kotlin, and iOS each provide a mechanism for generating a manifest file from your app source.

> If your client app uses another GraphQL client library, you can build your _own_ mechanism for generating operation manifests. See the expected [manifest format](#manifest-format).

See the instructions for your client library:

##### Apollo Client Web

1. In your app's project, install the `@apollo/generate-persisted-query-manifest` package as a dev dependency:

    ```bash
    npm install --save-dev @apollo/generate-persisted-query-manifest
    ```

    This package includes a CLI command you can run to generate a manifest file from your application source.

2. Generate your first manifest with the following command:

    ```bash
    npx generate-persisted-query-manifest
    ```

    - **If the command succeeds,** your manifest is written to `persisted-query-manifest.json`.
    - **If the command fails** (or if your manifest doesn't include all of the operations you expect it to), you can configure the command's behavior using the options described in the [package README](https://www.npmjs.com/package/@apollo/generate-persisted-query-manifest).

##### Apollo Kotlin

> Manifest generation requires Apollo Kotlin `3.8.2` or later.

To generate an operation manifest with Apollo Kotlin, you modify your project's [Gradle plugin configuration](/kotlin/advanced/plugin-configuration) to generate a manifest in addition to standard Kotlin source for your operations:

```kotlin
apollo {
  service("myapi") {
    operationManifestFormat.set("persistedQueryManifest") //highlight-line
  }
}
```

##### Apollo iOS

> Manifest generation requires Apollo iOS `1.3.1` or later.

To generate an operation manifest with Apollo iOS, you use the same [code generation engine](/ios/code-generation/introduction) that you use to generate Swift code for each of your operations.

Specifically, you modify the engine's file output configuration to include the output of an `operationManifest`. [See the full configuration reference.](/ios/code-generation/codegen-configuration#file-output)

### 4. Publish manifests to the PQL

> You perform this step for _each_ of your client apps. Coordinate this process with representatives from your client teams.

After you [generate an operation manifest](#3-generate-client-operation-manifests), you publish it to your PQL with the [Rover CLI](/rover/):

```bash title="Example command"
rover persisted-queries publish my-graph@my-variant \
  --manifest ./persisted-query-manifest.json
```

- Replace `my-graph@my-variant` with the **graph ref** of _any_ variant that your PQL is [linked to](#2-link-the-pql-to-variants).
    - Graph refs have the format `graph-id@variant-name`.
- For the `--manifest` option, provide the path to the manifest you want to publish.

<blockquote>

As with [generating manifests](#3-generate-client-operation-manifests), you execute this command in your CI/CD pipeline to publish new operations as part of your app release process.

</blockquote>

**The above command does the following:**

1. It publishes all operations in the provided manifest file to whichever PQL is linked to the specified variant.
    - Publishing a manifest to a PQL is additive. Any _existing_ entries in the PQL remain.
    - If you publish an operation with the same `id` but different details from an existing entry in the PQL, the entire publish command fails with an error.

2. It updates any _other_ variants that the PQL is applied to, so routers associated with those variants can fetch their updated PQL.

### 5. Configure your router

After you [publish all operations](#4-publish-manifests-to-the-pql) to your PQL, you can configure your router instances to fetch and _use_ your PQL.

1. As mentioned in [Prerequisites](#0-prerequisites):
    - Make sure you're using version `1.25.0` or later of the Apollo Router.
    - Make sure your router instances are [connected to your GraphOS Enterprise organization](/router/enterprise-features/#enabling-enterprise-features), and that they're associated with a variant that your PQL is linked to.

2. Set your desired persisted query behavior in your router's YAML config file. For supported options, see [Router security levels](#router-security-levels).

3. Deploy your updated router instances to begin using your PQL.

### 6. Send a test operation

First, start your GraphOS-connected router:

```bash
APOLLO_KEY="..." APOLLO_GRAPH_REF="..." ./router --config ./router.yaml

2023-05-11T15:32:30.684460Z  INFO Apollo Router v1.18.1 // (c) Apollo Graph, Inc. // Licensed as ELv2 (https://go.apollo.dev/elv2)
2023-05-11T15:32:30.684480Z  INFO Anonymous usage data is gathered to inform Apollo product development.  See https://go.apollo.dev/o/privacy for details.
2023-05-11T15:32:31.507085Z  INFO Health check endpoint exposed at http://127.0.0.1:8088/health
2023-05-11T15:32:31.507823Z  INFO GraphQL endpoint exposed at http://127.0.0.1:4000/ 🚀
```

Next, make an "APQ-style" POST request with `curl`, like so:

```bash
curl http://localhost:4000 -X POST --json \
'{"extensions":{"persistedQuery":{"version":1,"sha256Hash":"dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f"}}}'
```

If your router's PQL includes an operation with an ID that matches the value of the provided `sha256Hash` property, it executes the corresponding operation and returns its result.

### 7. Update client apps

After your router is running with persisted queries enabled, you can start updating your client apps to execute operations by their PQL-specified ID, instead of by sending full query strings.

To do this, clients can use the same protocol that's used for automatic persisted queries (APQ). 

Here's the JSON body of a request to execute an operation by its ID:

```json
{
  "variables": null,
  "extensions": {
    "persistedQuery": {
      "version": 1,
      "sha256Hash": "PQL_ID_HERE"
    }
  }
}
```

> If you're executing an operation that includes GraphQL variables, specify them with the `variables` property.

If your GraphQL client library provides a mechanism for executing operations via APQ, you can use that same mechanism with your router's PQL.

Here are links to documentation for APQ mechanisms in Apollo Client libraries:

- [Apollo Client Web](/react/api/link/persisted-queries/)
- [Apollo iOS](/ios/fetching/apqs/)
- [Apollo Kotlin](/kotlin/advanced/persisted-queries/)

## Manifest format

<blockquote>

⚠️ **This manifest format is subject to change during the preview period.**

You only need to read this section if you're building your own tooling to [generate persisted query manifests](#generating-manifests).

</blockquote>

A persisted query manifest has the following minimal structure:

```json title="persisted-queries-manifest.json"
{  
  "format": "apollo-persisted-queries",
  "version": 1,
  "operations": [  
    {
      "id": "dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f",
      "body": "query UniversalQuery { __typename }",
      "name": "UniversalQuery",
      "type": "query" 
    }
  ]
}
```

Manifest properties are documented below.

### Top-level properties

<table class="field-table">
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

###### `format`

</td>
<td>

This value is currently always `apollo-persisted-queries`.

</td>
</tr>

<tr>
<td>

###### `version`

</td>
<td>

This value is currently always `1`.

</td>
</tr>

<tr>
<td>

###### `operations`

</td>
<td>

An array of objects describing the individual GraphQL operations to publish.

For details, see [Per-operation properties](#per-operation-properties).

</td>
</tr>

</tbody>
</table>

### Per-operation properties

Each entry in a [manifest's](#manifest-format) `operations` array is a JSON object that describes a single GraphQL operation to publish:

```json
{
  "id": "dc67510fb4289672bea757e862d6b00e83db5d3cbbcfb15260601b6f29bb2b8f",
  "body": "query UniversalQuery { __typename }",
  "name": "UniversalQuery",
  "type": "query" 
}
```

Each operation object has the following properties:

<table class="field-table">
  <thead>
    <tr>
      <th>Property</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

###### `id`

</td>
<td>

The unique ID to use for the operation in your PQL.

**This value must be unique among operations in the PQL.** If you publish an operation with the same `id` as an existing operation, the new operation _overwrites_ the existing PQL entry.

**To ensure uniqueness,** tooling should generate this value based on the operation `body`. For details, see [Generating IDs](#generating-ids).

</td>
</tr>

<tr>
<td>

###### `body`

</td>
<td>

The complete query document for the operation. Includes the definition of the operation itself, along with accompanying fragment definitions.

**This string must match _exactly_ the query document that your client sends your router, including whitespace and field order.** For details, see [Ensuring consistent operation signatures](#ensuring-consistent-operation-signatures).

</td>
</tr>

<tr>
<td>

###### `name`

</td>
<td>

The operation's name. Must match the name specified in `body`.

This value does _not_ need to be unique among operations in the PQL. Often, different clients execute slightly different operations with the same name, and those operations each require a separate entry in the PQL.

</td>
</tr>

<tr>
<td>

###### `type`

</td>
<td>

The type of GraphQL operation. Always one of the following values:

- `query`
- `mutation`
- `subscription`

</td>
</tr>

</tbody>
</table>

### Generating IDs

When generating operation IDs for a manifest, you should use a value that's unique to each operation, such as the query document's cryptographic hash. Apollo's [manifest generation tools](#3-generate-operation-manifests) use the base16 representation of the document's SHA256 hash, which is the same format used for [APQ](#differences-from-apq).

By generating identifiers based on query documents this way, you ensure that different operations always have different IDs. This prevents unexpected collisions in your PQL.

> **Never use an operation _names_ for PQL IDs.** Different clients (or even different versions of the _same_ client) might execute different operations with the same name, and _all_ of those distinct operations should be present in your PQL.

### Ensuring consistent operation signatures

Whenever a client sends an operation string to a router that has safelisting enabled, the router checks for that operation string's presence in its persisted query list. **The incoming string must match a PQL entry's operation string _exactly_, including whitespace and field order.**

The following queries are functionally identical, but the router will _reject_ the client operation because it doesn't match the PQL entry exactly:

<CodeColumns>

```graphql title="PQL entry"
query GetBooks {
  books {
    author
    title
  }
}
```

```graphql title="Client operation"
query GetBooks {
  books {
    #highlight-start
    title # Field order reversed!
    author
    #highlight-end
  }
}
```

</CodeColumns>

To ensure that you generate manifest entries correctly, it's important to note that your app's client library might potentially _modify_ the operation strings you define in your source before executing those corresponding operations. For example, by default all Apollo Client libraries add the `__typename` field to every object in a query (if that field isn't already present):

<CodeColumns>

```graphql title="Source-defined query"
query GetBooks {
  books {
    author
    title
  }
}
```

```graphql title="Client-executed query"
query GetBooks {
  books {
    author
    title
    __typename #highlight-line
  }
}
```

</CodeColumns>

> The [manifest generation tools](#3-generate-client-operation-manifests) for Apollo Client libraries all account for this default behavior.

If you're building your own manifest generation tool, make sure it accounts for any such operation changes in your chosen client library. Otherwise, the router will reject your app's operations due to a query string mismatch.

Similarly, if your clients execute operations by providing their PQL-specified ID, they might end up executing an operation with a different shape than expected if you don't account for these operation changes.
