---
title: GraphOS schema linter rules
description: Reference
---

This reference lists the rules that you can enforce with [GraphOS schema linting](./schema-linter/), along with the code that GraphOS returns for each rule violation.

Rules are categorized by the part(s) of your schema that they correspond to.

## Static rules

### Schema

#### `DOES_NOT_PARSE`

The schema linter raises this violation if it attempts to read a malformed GraphQL schema. Check your schema for any syntax errors.

<hr/>

#### `QUERY_DOCUMENT_DECLARATION`

A GraphQL schema should never include definitions of GraphQL _operations_ (such as queries and mutations).

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type Query {
  users: [User!]!
}

#highlight-start
query GetUsers { # Don't define operations in a schema document
  users {
    id
  }
}
#highlight-end
```

### All fields

#### `FIELD_NAMES_SHOULD_BE_CAMEL_CASE`

Field names should always use `camelCase`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type User {
  # highlight-start
  FirstName: String! # PascalCase
  # highlight-end
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type User {
  # highlight-start
  firstName: String # camelCase
  # highlight-end
}
```

<hr/>

#### `RESTY_FIELD_NAMES`

A field's name should never start with any of the following verbs:

- `get`
- `list`
- `post`
- `put`
- `patch`

> Most fields should not start with _any_ verb, with the exception of `Mutation` fields. For `Mutation` fields, use a verb that more specifically describes the action being performed (such as `create`, `delete`, or `edit`).

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type Query {
  getUsers: [User!]! # highlight-line
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type Query {
  users: [User!]! # highlight-line
}
```

### All types

These rules apply to _all_ types that appear in a GraphQL schema, including:

- Objects
- Interfaces
- Inputs
- Enums
- Unions

#### `TYPE_NAMES_SHOULD_BE_PASCAL_CASE`

All type names should use `PascalCase`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
# highlight-start
type streamingService { # camelCase
# highlight-end
  id: ID!
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
# highlight-start
type StreamingService { # PascalCase
# highlight-end
  id: ID!
}
```

<hr/>

#### `TYPE_PREFIX`

Type names should never use the prefix `Type`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type TypeBook { # highlight-line
  title: String!
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type Book { # highlight-line
  title: String!
}
```

<hr/>

#### `TYPE_SUFFIX`

Type names should never use the suffix `Type`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type BookType { # highlight-line
  title: String!
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type Book { # highlight-line
  title: String!
}
```

### Objects

#### `OBJECT_PREFIX`

An object type's name should never use the prefix `Object`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type ObjectBook { # highlight-line
  title: String!
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type Book { # highlight-line
  title: String!
}
```

<hr/>

#### `OBJECT_SUFFIX`

An object type's name should never use the suffix `Object`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type BookObject { # highlight-line
  title: String!
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type Book { # highlight-line
  title: String!
}
```

### Interfaces

#### `INTERFACE_PREFIX`

An interface type's name should never use the prefix `Interface`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
interface InterfaceBook { # highlight-line
  title: String
  author: String
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
interface Book { # highlight-line
  title: String
  author: String
}
```

<hr/>

#### `INTERFACE_SUFFIX`

An interface type's name should never use the suffix `Interface`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
interface BookInterface { # highlight-line
  title: String
  author: String
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
interface Book { # highlight-line
  title: String
  author: String
}
```

### Inputs & arguments

#### `INPUT_ARGUMENT_NAMES_SHOULD_BE_CAMEL_CASE`

A GraphQL argument's name should always use `camelCase`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type Mutation {
  #highlight-start
  createBlogPost(BlogPostContent: BlogPostContent!): Post # PascalCase
  #highlight-end
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type Mutation {
  #highlight-start
  createBlogPost(blogPostContent: BlogPostContent!): Post # camelCase
  #highlight-end
}
```

<hr/>

#### `INPUT_TYPE_SUFFIX`

An input type's name should always use the suffix `Input`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
input BlogPostDetails { #highlight-line
  title: String!
  content: String!
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
input BlogPostDetailsInput { #highlight-line
  title: String!
  content: String!
}
```

### Enums

#### `ENUM_VALUES_SHOULD_BE_SCREAMING_SNAKE_CASE`

Enum values should always use `SCREAMING_SNAKE_CASE`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
enum Amenity {
  # highlight-start
  public_park # snake_case
  # highlight-end
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
enum Amenity {
  # highlight-start
  PUBLIC_PARK # SCREAMING_SNAKE_CASE üò±
  # highlight-end
}
```

<hr/>

#### `ENUM_PREFIX`

An enum type's name should never use the prefix `Enum`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
enum EnumResidence { # highlight-line
  HOUSE
  APARTMENT
  CONDO
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
enum Residence { # highlight-line
  HOUSE
  APARTMENT
  CONDO
}
```

<hr/>

#### `ENUM_SUFFIX`

An enum type's name should never use the suffix `Enum`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
enum ResidenceEnum { # highlight-line
  HOUSE
  APARTMENT
  CONDO
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
enum Residence { # highlight-line
  HOUSE
  APARTMENT
  CONDO
}
```

<hr/>

#### `ENUM_USED_AS_INPUT_WITHOUT_SUFFIX`

If an enum type is used as an input argument, its name _should_ use the suffix `Input`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
enum Role { # highlight-line
  EDITOR
  VIEWER
}

type Query {
  users(role: Role): [User!]! # highlight-line
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
enum RoleInput { # highlight-line
  EDITOR
  VIEWER
}

type Query {
  users(role: RoleInput): [User!]! # highlight-line
}
```

<hr/>

#### `ENUM_USED_AS_OUTPUT_DESPITE_SUFFIX`

If an enum is used as the return type of a _non_-input field, its name _should not_ use the suffix `Input`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
enum RoleInput { # highlight-line
  EDITOR
  VIEWER
}

type Query {
  userRole(userId: ID!): RoleInput # highlight-line
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
enum Role { # highlight-line
  EDITOR
  VIEWER
}

type Query {
  userRole(userId: ID!): Role # highlight-line
}
```

### Directives

#### `DIRECTIVE_NAMES_SHOULD_BE_CAMEL_CASE`

Directive names should always use `camelCase`.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
directive @SpecialField on FIELD_DEFINITION # PascalCase
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
directive @specialField on FIELD_DEFINITION # camelCase
```

<hr/>

#### `CONTACT_DIRECTIVE_MISSING`

A subgraph schema should always provide owner contact details via the `@contact` directive. [Learn more.](../graphs/federated-graphs#contact-info-for-subgraphs)


<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
directive @contact(
  "Contact title of the subgraph owner"
  name: String!
  "URL where the subgraph's owner can be reached"
  url: String
  "Other relevant notes can be included here; supports markdown links"
  description: String
) on SCHEMA

extend schema @contact(
  name: "Products Team",
  url: "https://myteam.slack.com/archives/teams-chat-room-url",
  description: "Send urgent issues to [#oncall](https://yourteam.slack.com/archives/oncall)."
)
```

<hr/>

#### `DEPRECATED_DIRECTIVE_MISSING_REASON`

The `@deprecated` directive should always include a `reason` argument.

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="schema.graphql"
type Product {
  title: String @deprecated #highlight-line
  name: String!
}
```

<p style="margin-bottom: 0">‚úÖ</p>

```graphql title="schema.graphql"
type Product {
  title: String @deprecated(reason: "Use Product.name instead") #highlight-line
  name: String!
}
```

<hr/>

#### `TAG_DIRECTIVE_USES_UNKNOWN_NAME`

The `@tag` directive should always use an approved value for its `name` argument. You specify approved values in [GraphOS Studio](./schema-linter/#configuring-the-linter).


<MinVersion version="2.5">

## Composition rules

</MinVersion>

> Composition rules are only available for graphs on [federation version `2.5`](/federation/federation-versions) or later. You can update a graph's version from its **Settings** page in [GraphOS Studio](https://studio.apollographql.com?referrer=docs-content).

These rules flag potential improvements to a supergraph schema [composed](/federation/federated-types/composition) of [subgraph](/federation/building-supergraphs/subgraphs-overview/) schemas.

### Inconsistent elements

#### `INCONSISTENT_ARGUMENT_PRESENCE`

Indicates that an optional argument (of a field or directive definition) isn't present in all subgraphs and therefore won't be part of the supergraph.

<hr/>

#### `INCONSISTENT_BUT_COMPATIBLE_ARGUMENT_TYPE`

Indicates that an argument type (of a field, input field, or directive definition) doesn't have the exact same type in all subgraphs, but that the types are compatible.

Two types are compatible if one is:
- a non-nullable version
- a list version
- a subtype
- or a combination of any of these

of the other.

<hr/>

#### `INCONSISTENT_BUT_COMPATIBLE_FIELD_TYPE`

Indicates that a field doesn't have the exact same types in all subgraphs, but that the types are compatible.

Two types are compatible if one is:
- a non-nullable version
- a list version
- a subtype
- or a combination of any of these

of the other.

<hr/>

#### `INCONSISTENT_DEFAULT_VALUE_PRESENCE`

Indicates that an argument definition (of a field, input field, or directive definition) has a default value in only some of the subgraphs that define the argument.

<hr/>

#### `INCONSISTENT_DESCRIPTION`

Indicates that an element has a description in more than one subgraph, and the descriptions aren't equal.

<hr/>

#### `INCONSISTENT_ENTITY`

Indicates that an object is declared as an entity (has a `@key`) in only some of the subgraphs in which the object is defined.

<hr/>

#### `INCONSISTENT_ENUM_VALUE_FOR_INPUT_ENUM`

Indicates that a value of an enum type definition, that is only used as an input type, hasn't been merged into the supergraph because it's defined in only some of the subgraphs that declare the enum.

<hr/>

#### `INCONSISTENT_ENUM_VALUE_FOR_OUTPUT_ENUM`

Indicates that a value of an enum type definition, that is only used as an output type or is unusedm, _has_ been merged in the supergraph but is defined in only some of the subgraphs that declare the enum.

<hr/>

#### `INCONSISTENT_EXECUTABLE_DIRECTIVE_LOCATIONS`

Indicates that an executable directive definition is declared with inconsistent locations across subgraphs. (The supergraph schema then uses the intersection of all locations in the supergraph.)

<hr/>

#### `INCONSISTENT_EXECUTABLE_DIRECTIVE_PRESENCE`

Indicates that an executable directive definition is declared in only some of the subgraphs.

<hr/>

#### `INCONSISTENT_EXECUTABLE_DIRECTIVE_REPEATABLE`

Indicates that an executable directive definition is marked repeatable in only some of the subgraphs and won't be repeatable in the supergraph.

<hr/>

#### `INCONSISTENT_INPUT_OBJECT_FIELD`

Indicates that a field of an input object type definition is only defined in some of the subgraphs that declare the input object.

<hr/>

#### `INCONSISTENT_INTERFACE_VALUE_TYPE_FIELD`

Indicates that a field of an interface "value type" (has no `@key` in any subgraph) isn't defined in all the subgraphs that declare the type.

<hr/>

#### `INCONSISTENT_NON_REPEATABLE_DIRECTIVE_ARGUMENTS`

A non-repeatable directive is applied to a schema element in different subgraphs but with arguments that are different.

<hr/>

#### `INCONSISTENT_OBJECT_VALUE_TYPE_FIELD`

Indicates that a field of an object "value type" (has no `@key` in any subgraph) isn't defined in all the subgraphs that declare the type.

<hr/>

#### `INCONSISTENT_RUNTIME_TYPES_FOR_SHAREABLE_RETURN`

Indicates that a @shareable field returns different sets of runtime types in the different subgraphs in which it's defined.

<hr/>

#### `INCONSISTENT_TYPE_SYSTEM_DIRECTIVE_LOCATIONS`

Indicates that an executable directive definition is marked repeatable in only some of the subgraphs and will not be repeatable in the supergraph.

<hr/>

#### `INCONSISTENT_TYPE_SYSTEM_DIRECTIVE_REPEATABLE`

Indicates that a type system directive definition is marked repeatable in only some of the subgraphs that declare the directive and will be repeatable in the supergraph.

<hr/>

#### `INCONSISTENT_UNION_MEMBER`

Indicates that a member of a union type definition is only defined in some of the subgraphs that declare the union.

### Overridden and unused elements

#### `OVERRIDE_DIRECTIVE_CAN_BE_REMOVED`

Indicates a field with the @override directive no longer exists in a source subgraph, so the directive can be safely removed.

<hr/>

#### `OVERRIDDEN_FIELD_CAN_BE_REMOVED`

Indicates that a field has been overridden by another subgraph. You should consider removing the overriden field to avoid confusion.

<hr/>

#### `UNUSED_ENUM_TYPE`

Indicates that an enum type is defined in some subgraphs but is unused (no field/argument references it). All values from subgraphs defining that enum will be included in the supergraph.

### Directives

#### `DIRECTIVE_COMPOSITION`

Indicates that an issue was detected when composing custom directives.

<hr/>

#### `MERGED_NON_REPEATABLE_DIRECTIVE_ARGUMENTS`

Indicates a non-repeatable directive has been applied to a schema element in different subgraphs with different arguments and the arguments values were merged using the directive configured strategies.

<hr/>

#### `NO_EXECUTABLE_DIRECTIVE_INTERSECTION`

For an executable directive definition, indicates that no location appears for it in any subgraphs.

#### `FROM_SUBGRAPH_DOES_NOT_EXIST`

Indicates the source subgraph specified by @override directive doesn't exist.
