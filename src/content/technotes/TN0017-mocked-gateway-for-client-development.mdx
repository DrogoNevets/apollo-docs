---
title: "Using Apollo Gateway mocks to increase development velocity"
id: TN0017
tags: [gateway, best practices, schema design, federation]
---

## Problem statement

As you begin to grow your graph, you may soon realize that your client teams are often waiting on subgraph owners to make agreed upon changes to the schema. This is especially common in earlier stages of your graph journey, where your graph has an agreed-upon structure, but has not been implemented yet from your subgraph team(s). Mocking your graph as you build both your clients and subgraphs can help enable teams to work in tandem and removes dependencies on one another.

Being able to work in parallel helps increase your development speed, and Apollo has a few suggested ways to enable parallel development during your graph evolution.

## Plan your schema

Effectively using mocks requires that your schema has been determined by both client and backend teams as part of a larger [governance strategy](/enterprise-guide/graph-administration#governance) and approval process. Regardless of option, having agreement from both client and backend teams on the schema additions/removals/changes can help make your schema more useful and expressive.

In general, we recommended defining your schema ahead of time regardless of whether you implement this strategy or not, as it allows for teams to create an expressive, agreed-upon schema that empowers both backend and client teams to have input in the result.

### New Schema

If starting on a new schema, it is important to start with fundamentals and best-practices, such as those listed on [Odyssey](https://www.apollographql.com/tutorials), [Principled GraphQL](https://principledgraphql.com/), and [Enterprise Guide](/enterprise-guide/introduction) and design the schema afterwards.

For new schemas, we'd recommend using [this sample by GitHub user setchy](https://github.com/setchy/apollo-server-4-mocked-federation) to mock your new schema in it's entirety. This will enable your client teams to have a local (or hosted) instance of the schema to create client requests to and begin mocking UI with the mocked data.

You'll need to [publish your schema to Apollo Studio](/graphos/schema/cli-registration) for use with this sample. For reasons [why to publish to Apollo Studio, see the below section](#why-use-apollo-studio-for-a-mocked-server).

To get started with the sample, run the following:

```bash
git clone https://github.com/setchy/apollo-server-4-mocked-federation
cd apollo-server-4-mocked-federation
npm install
cp .env.template .env
```

Afterwards, edit the `.env` file with the appropriate values from Apollo Studio, and then run the following to start the server:

```bash
npm run dev
```

The sample leverages `@graphql-tools/mock` to power the mocks, and can be extended following the [package's documentation page](https://www.the-guild.dev/graphql/tools/docs/mocking).

This gateway can then be used either locally (such as for local client development) or as a hosted gateway internally to be used by client developers.

The data is mocked, however it doesn't require any work from server teams to support and will match the schema as it exists within Apollo Studio. As we're using Apollo Studio for the schema, schema changes will automatically be pulled ensuring client developers are working on the latest version.

### Schema Changes

Making changes to your schema operate in much the same way as building your first schema, especially in a planning capacity. As new features are inevitably made, it's important to think about how quickly your teams need to ship, especially for features that require intensive backend work (e.g. machine learning, new services, etc).

To mock proposed changes (such as adding a new type/field), we'd recommend using [this sample created by Apollo's Solutions Architecture team](https://github.com/apollosolutions/apollo-faker-demo), as it requires a pre-existing GraphQL API to be running. This example works by allowing for a "patched"/modified version of your subgraph to run locally with mocked data, while leveraging the remote API for all other data.

You'll need to [publish your schema to Apollo Studio](/graphos/schema/cli-registration) for use with this sample. For reasons [why to publish to Apollo Studio, see the below section](#why-use-apollo-studio-for-a-mocked-server).

To get started, run:

```graphql
mkdir mocked_gateway
export APOLLO_KEY=key_from_studio #replace with the actual key from Apollo Studio
cd mocked_gateway
touch proposed.graphql
npx github:@apollosolutions/apollo-faker-demo --graphref <yourgraph>@<variant> --remote https://yourapi.com/graphql
```

And then modify the `proposed.graphql` file with the proposed changes. There are configuration options available leveraging the `@graphql-tools/mock` package, and can be modified as denoted in [the sample's README file, under step 5](https://github.com/apollosolutions/apollo-faker-demo#usage).

## Why use Apollo Studio for a mocked server?

Now that you have either a new schema or changes, it's important to upload it into [Apollo Studio](https://studio.apollographql.com) for three reasons:

1. It allows for a centralized view of the schema, along with a [mocked view of the schema](/graphos/explorer/additional-features/#mocked-responses).
2. It allows for the samples referenced below to automatically update on changes, allowing for a deployed version of the samples to be referenced by all developers.
3. For client teams using code generation tools, especially those in Apollo's clients, it's possible to use Studio as a source of the schema allowing for easier development.

We recommend using a variant of your new/existing production graph ID. If considering mocking for schema changes, this also ensures proposed changes aren't breaking using [schema checks](/graphos/schema-checks) against production traffic.
