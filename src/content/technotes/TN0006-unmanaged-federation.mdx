---
title: TN0006 - Using Unmanaged Federation
id: TN0006
tags: [federation, gateway]
---

[Managed Federation]([https://www.apollographql.com/docs/federation/managed-federation/overview/](https://www.apollographql.com/docs/federation/managed-federation/overview/)) is, in short, a way to run a federated graph utilizing Apollo Studio to provide the necessary supergraph file to your Apollo Gateway or Router using [Apollo Uplink](https://www.apollographql.com/docs/federation/managed-federation/uplink/). Unmanaged Federation, on the other hand, is running a federated graph without the use of [Apollo Uplink](https://www.apollographql.com/docs/federation/managed-federation/uplink/), which requires additional work to support effectively. If you are considering running an unmanaged federated graph, there are a few considerations to keep in mind when doing so.

### Graph Composition

There are a few ways to compose your supergrpah that will allow you to use it with your Apollo Gateway or Router, two of which are discussed below. 

#### Build Status Webhook

This approach uses the [Build Status Webhook](https://www.apollographql.com/docs/studio/build-status-notification) to trigger a redeployment of a Gateway or Router by updating on successful builds with a pre-composed supergraph file provided by Apollo Studio. The payload of the webhook contains a URL to fetch the supergraph file necessary, and can be used to download the supergraph file. 

The advantage of this approach is that you have a confirmed build that composes successfully, however an important note is that this is _prior_ to any schema checks being run. This means you should have [Rover run a schema check as part of a CI/CD pipeline](https://www.apollographql.com/docs/rover/commands/subgraphs/#checking-subgraph-schema-changes).

#### Local Composition

When running Unmanaged Federation you can leverage [Rover]([https://www.apollographql.com/docs/rover/](https://www.apollographql.com/docs/rover/)) to build the supergraph as part of a larger CI/CD pipeline in order to then be used by your Apollo Gateway or Router, similar to the above. 

The process for setting this up can vary depending on CI tooling, but you'll need to leverage `rover supergraph compose` to build the supergraph GraphQL file from a configuration file. Additionally, you'll need to:

- Track all subgraphs and routing URLs
- Be able to trigger the build on any new updates to any subgraphs

You can use the [Build Status Webhook](https://www.apollographql.com/docs/studio/build-status-notification) to do so if you want to leverage Apollo Studio, but would prefer to build locally.

To run the `rover supergraph compose` command, you'll need access to each subgraph's schema SDL. There are a few ways to do this: 

- Leveraging `rover subgraph introspect` to pull the schema via introspection
- Pulling the schema from a version control service, such as Github or Gitlab

As with the above [Build Status Webhook section](#build-status-webhook), you should be cognizant to use [Rover to run a schema check as part of a CI/CD pipeline](https://www.apollographql.com/docs/rover/commands/subgraphs/#checking-subgraph-schema-changes) or during build time to ensure the changes are not going to break clients. 

For more information on how to accomplish this, see: 

- [https://www.apollographql.com/docs/rover/commands/supergraphs#supergraph-compose](https://www.apollographql.com/docs/rover/commands/supergraphs#supergraph-compose)
- [https://www.apollographql.com/docs/federation/quickstart/local-composition](https://www.apollographql.com/docs/federation/quickstart/local-composition)

### Using the Supergraph File

Similar to getting the supergraph composed, there are a number of ways to approach updating the supergraph in your Gateway or Router. Three options are discussed below. 

#### Restarting Gateway/Router

The simplest option is to simply restart your Gateway or Router processes. If you passed the file into the instances via a build process (such as a Docker image), you can redeploy to take effect. This isn't recommended as there are ways to avoid any redeployments, discussed below.

#### Hot Reloading

**If you are using the Router, you can use the `--hr` flag to enable hot reloading natively; no further configuration is needed**

The flip of restarting processes in Gateway is to enable hot reloading the file using a simple watcher. 

For example, if you're using Docker you can pass in the file as a mounted volume such as the below where the local supergraph file is mounted to `/etc/config/supergraph.graphql` for the Gateway to use. 

```Dockerfile
version: '3'
services:
  apollo-gateway:
    container_name: apollo-gateway
    build: ./gateway
    volumes:
      - ./supergraph.graphql:/etc/config/supergraph.graphql
    ports:
```

Once you've passed the file to the instances, you'll want to make sure to use the `supergraphSdl` option in Gateway to hot reload the graph. An example of this would be below, which uses `chokidar` to watch for file updates. 

To simplify the code example, the `ApolloGateway` options now accepts a `supergaphSdl` property. This property can either be a string, or it can be a function that allows for updating the supergraph during runtime as shown below.  

```js
const { ApolloServer } = require('apollo-server');
const { ApolloGateway } = require('@apollo/gateway');
const { readFile } = require('fs/promises');
const chokidar = require('chokidar');
const supergraphSdlLocation = '/etc/config/supergraph.graphql';

const gateway = new ApolloGateway({
  async supergraphSdl({ update, healthCheck }) {
    const watcher = chokidar.watch(supergraphSdlLocation);
    watcher.on('change', async ()=>{
      try {
          const updatedSupergraph = await readFile(supergraphSdlLocation, 'utf-8');
          // optional health check update to ensure our services are responsive
          await healthCheck(updatedSupergraph);
          // update the supergraph schema
          update(updatedSupergraph);
        } catch (e) {
          // handle errors that occur during health check or while updating the supergraph schema
          console.error(e);
        }
    });
    return {
      supergraphSdl: await readFile(supergraphSdlLocation, 'utf-8'),
      async cleanup() {
        await watcher.close();
      }
    }
  },
});

const server = new ApolloServer({
  gateway,
});
server.listen().then(({ url }) => {
  console.log(`ðŸš€ Server ready at ${url}`);
});
```

For more information on this approach, we recommend [checking out the Gateway docs to learn more](https://github.com/apollographql/federation/blob/main/docs/source/gateway.mdx#updating-the-supergraph-schema) including further steps to harden the implementation. 

#### Custom SupergraphManager

Lastly, if you have complex logic that would be better suited for a seperate class (for example, listening to an AWS Simple Notification Service (SNS) topic), you can create a custom implementation of the `SupergraphManager` class to be passed to the `supergraphSdl` option described earlier. 

This option provides the most customizability, but comes at the cost of writing additional code- however the interface for writing the class is extremly simple. For an example, [see the Uplink implementation of `SupergraphManager` on how to do so](https://github.com/apollographql/federation/blob/main/gateway-js/src/supergraphManagers/UplinkSupergraphManager/index.ts). 
