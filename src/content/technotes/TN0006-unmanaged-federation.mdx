---
title: Using unmanaged federation
id: TN0006
tags: [federation, gateway]
---

With [managed federation](/federation/managed-federation/overview/), your federated supergraph's gateway or router automatically fetches its composed supergraph schema from Apollo. If your supergraph _doesn't_ use managed federation, you need to compose the supergraph schema and provide it to your gateway via another mechanism. This article describes options and considerations for that process.

## Composing the supergraph schema

Options for composing your supergraph schema _besides_ managed federation are described below.

### Build status webhook

This approach uses the [build status webhook](/studio/build-status-notification) to trigger redeployment of a gateway or router by updating on successful builds with a composed supergraph schema provided by Apollo Studio. The payload of the webhook contains a URL to download the composed schema. 

The advantage of this approach is that you have a confirmed build that composes successfully, however an important note is that this is _prior_ to any schema checks being run. This means you should have [Rover run a schema check as part of a CI/CD pipeline](https://www.apollographql.com/docs/rover/commands/subgraphs/#checking-subgraph-schema-changes).

### Local composition

You can use the [Rover CLI](/rover/) to compose your supergraph schema as part of your CI/CD pipeline. You then provide this schema directly to your gateway or router.

The process for setting this up can vary depending on CI tooling, but you'll need to leverage `rover supergraph compose` to build the supergraph GraphQL file from a configuration file. Additionally, you'll need to:

- Track all subgraphs and routing URLs
- Be able to trigger the build on any new updates to any subgraphs

You can use the [Build Status Webhook](https://www.apollographql.com/docs/studio/build-status-notification) to do so if you want to leverage Apollo Studio, but would prefer to build locally.

To run the `rover supergraph compose` command, you'll need access to each subgraph's schema SDL. There are a few ways to do this: 

- Leveraging `rover subgraph introspect` to pull the schema via introspection
- Pulling the schema from a version control service, such as Github or Gitlab

As with the above [Build Status Webhook section](#build-status-webhook), you should be cognizant to use [Rover to run a schema check as part of a CI/CD pipeline](https://www.apollographql.com/docs/rover/commands/subgraphs/#checking-subgraph-schema-changes) or during build time to ensure the changes are not going to break clients. 

For more information on how to accomplish this, see: 

- [https://www.apollographql.com/docs/rover/commands/supergraphs#supergraph-compose](https://www.apollographql.com/docs/rover/commands/supergraphs#supergraph-compose)
- [https://www.apollographql.com/docs/federation/quickstart/local-composition](https://www.apollographql.com/docs/federation/quickstart/local-composition)

## Providing a composed supergraph schema

After you compose your supergraph schema, there are a few different ways to provide that file to your gateway or router:

### Hot reloading

**If you're using the Apollo Router,** you can enable hot reloading by passing the `--hr` option to the `router` executable. No other configuration is required.

**If you're using the `@apollo/gateway` library,** you can enable hot reloading by setting up a basic watcher.

For example, if you're using Docker, you can pass the supergraph schema file as a mounted volume. In the following example, the supergraph schema is mounted to `/etc/config/supergraph.graphql`:

```Dockerfile
version: '3'
services:
  apollo-gateway:
    container_name: apollo-gateway
    build: ./gateway
    volumes:
      - ./supergraph.graphql:/etc/config/supergraph.graphql
    ports:
```

After you make the schema file available to your gateway instances, pass a function to the `supergraphSdl` option of your `ApolloGateway` constructor that enables the gateway to hot reload the schema. The example function below uses the `chokidar` library to watch for file updates:

To simplify the code example, the `ApolloGateway` options now accepts a `supergaphSdl` property. This property can either be a string, or it can be a function that allows for updating the supergraph during runtime as shown below.  

```js
const { ApolloServer } = require('apollo-server');
const { ApolloGateway } = require('@apollo/gateway');
const { readFile } = require('fs/promises');
const chokidar = require('chokidar');
const supergraphSdlLocation = '/etc/config/supergraph.graphql';

const gateway = new ApolloGateway({
  async supergraphSdl({ update, healthCheck }) {
    const watcher = chokidar.watch(supergraphSdlLocation);
    watcher.on('change', async ()=>{
      try {
          const updatedSupergraph = await readFile(supergraphSdlLocation, 'utf-8');
          // optional health check update to ensure our services are responsive
          await healthCheck(updatedSupergraph);
          // update the supergraph schema
          update(updatedSupergraph);
        } catch (e) {
          // handle errors that occur during health check or while updating the supergraph schema
          console.error(e);
        }
    });
    return {
      supergraphSdl: await readFile(supergraphSdlLocation, 'utf-8'),
      async cleanup() {
        await watcher.close();
      }
    }
  },
});

const server = new ApolloServer({
  gateway,
});
server.listen().then(({ url }) => {
  console.log(`ðŸš€ Server ready at ${url}`);
});
```

For more information on this approach, [see the Apollo Gateway docs](/federation/gateway.mdx#updating-the-supergraph-schema).

### Custom `SupergraphManager`

If you have complex logic that's be better suited to its own class (for example, listening to an AWS Simple Notification Service (SNS) topic), you can create a custom implementation of the `SupergraphManager` class to pass to the `supergraphSdl` option.

This option provides the most customizability, but it also requires writing additional code. For an example, [see the Uplink implementation of `SupergraphManager`](https://github.com/apollographql/federation/blob/main/gateway-js/src/supergraphManagers/UplinkSupergraphManager/index.ts). 

If we were to write the same file watcher function as above as a `SupergraphManager`, it would look like: 

```ts
import { SupergraphManager } from '@apollo/gateway';
import { SupergraphSdlHookOptions } from '@apollo/gateway/dist/config';
import * as chokidar from 'chokidar';
import {readFile} from 'fs/promises';

export class FileWatcherManager implements SupergraphManager {
    private filename: string; 

    constructor({
        filename,
    }:{
        filename: string
    }){
        this.filename = filename
    }
    
    public async initialize({ update, healthCheck }: SupergraphSdlHookOptions) {
        let watcher = chokidar.watch(this.filename)

        watcher.on('change', async ()=>{
            try {
                const updatedSupergraph = await readFile(this.filename, 'utf-8');
                // optional health check update to ensure our services are responsive
                await healthCheck(updatedSupergraph);
                // update the supergraph schema
                update(updatedSupergraph);
            } catch (e) {
                // handle errors that occur during health check or while updating the supergraph schema
                console.error(e);
            }
        });
        
        return {
            supergraphSdl: await readFile(this.filename, 'utf-8'),
            cleanup: async () => {
                await watcher.close()
            },
          };
    }   
}
```

And to use it, you will instantiate it for the `sueprgraphSdl` property. For example:
```ts
const gateway = new ApolloGateway({
    supergraphSdl: new FileWatcherManager({filename: './supergraph.graphql'})
})
```

### Restart the gateway/router (not recommended)

The most straightforward option is to restart all of your gateway or router instances. If you pass your supergraph schema file to these instances via a build process (such as a Docker image), you can redeploy for your changes to take effect.

This method is _not_ recommended, because the restart causes downtime for your supergraph. The methods described above can update your supergraph schema _without_ requiring redeployment.